<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SolverTools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="SolverTools.jl logo"/></a><h1>SolverTools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Auxiliary-1">Auxiliary</a></li><li><a class="toctext" href="#Benchmarking-1">Benchmarking</a></li><li><a class="toctext" href="#Line-Search-1">Line-Search</a></li><li><a class="toctext" href="#Stats-1">Stats</a></li><li><a class="toctext" href="#Trust-Region-1">Trust-Region</a></li></ul></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/JuliaSmoothOptimizers/SolverTools.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><ul><li><a href="#API-1">API</a></li><ul><li><a href="#Auxiliary-1">Auxiliary</a></li><li><a href="#Benchmarking-1">Benchmarking</a></li><li><a href="#Line-Search-1">Line-Search</a></li><li><a href="#Stats-1">Stats</a></li><li><a href="#Trust-Region-1">Trust-Region</a></li></ul></ul><h2><a class="nav-anchor" id="Auxiliary-1" href="#Auxiliary-1">Auxiliary</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.active" href="#SolverTools.active"><code>SolverTools.active</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">active(x, ℓ, u; rtol = 1e-8, atol = 1e-8)</code></pre><p>Computes the active bounds at x, using tolerance <code>min(rtol * (uᵢ-ℓᵢ), atol)</code>. If ℓᵢ or uᵢ is not finite, only <code>atol</code> is used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.breakpoints" href="#SolverTools.breakpoints"><code>SolverTools.breakpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nbrk, brkmin, brkmax = breakpoints(x, d, ℓ, u)</code></pre><p>Find the smallest and largest values of <code>α</code> such that <code>x + αd</code> lies on the boundary. <code>x</code> is assumed to be feasible. <code>nbrk</code> is the number of breakpoints from <code>x</code> in the direction <code>d</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.compute_Hs_slope_qs!" href="#SolverTools.compute_Hs_slope_qs!"><code>SolverTools.compute_Hs_slope_qs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">slope, qs = compute_Hs_slope_qs!(Hs, H, s, g)</code></pre><p>Computes</p><pre><code class="language-none">Hs = H * s
slope = dot(g,s)
qs = ¹/₂sᵀHs + slope</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.log_header" href="#SolverTools.log_header"><code>SolverTools.log_header</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log_header(colnames, coltypes)</code></pre><p>Creates a header using the names in <code>colnames</code> formatted according to the types in <code>coltypes</code>. Uses internal formatting specification given by <code>SolverTools.formats</code> and default header translation given by <code>SolverTools.default_headers</code>.</p><p>Input:</p><ul><li><code>colnames::Vector{Symbol}</code>: Column names.</li><li><code>coltypes::Vector{DataType}</code>: Column types.</li></ul><p>Keyword arguments:</p><ul><li><code>hdr_override::Dict{Symbol,String}</code>: Overrides the default headers.</li><li><code>colsep::Int</code>: Number of spaces between columns (Default: 2)</li></ul><p>See also <a href="#SolverTools.log_row"><code>log_row</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.log_row" href="#SolverTools.log_row"><code>SolverTools.log_row</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">log_row(vals)</code></pre><p>Creates a table row from the values on <code>vals</code> according to their types. Pass the names and types of <code>vals</code> to <a href="#SolverTools.log_header"><code>log_header</code></a> for a logging table. Uses internal formatting specification given by <code>SolverTools.formats</code>.</p><p>Keyword arguments:</p><ul><li><code>colsep::Int</code>: Number of spaces between columns (Default: 2)</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.project!" href="#SolverTools.project!"><code>SolverTools.project!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">project!(y, x, ℓ, u)</code></pre><p>Projects <code>x</code> into bounds <code>ℓ</code> and <code>u</code>, in the sense of <code>yᵢ = max(ℓᵢ, min(xᵢ, uᵢ))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.project_step!" href="#SolverTools.project_step!"><code>SolverTools.project_step!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">project_step!(y, x, d, ℓ, u, α = 1.0)</code></pre><p>Computes the projected direction <code>y = P(x + α * d) - x</code>.</p></div></div></section><h2><a class="nav-anchor" id="Benchmarking-1" href="#Benchmarking-1">Benchmarking</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.bmark_solvers" href="#SolverTools.bmark_solvers"><code>SolverTools.bmark_solvers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bmark_solvers(solvers :: Dict{Symbol,Any}, args...; kwargs...)</code></pre><p>Run a set of solvers on a set of problems.</p><p><strong>Arguments</strong></p><ul><li><code>solvers</code>: a dictionary of solvers to which each problem should be passed</li><li>other positional arguments accepted by <code>solve_problems()</code>, except for a solver name</li></ul><p><strong>Keyword arguments</strong></p><p>Any keyword argument accepted by <code>solve_problems()</code></p><p><strong>Return value</strong></p><p>A Dict{Symbol, AbstractExecutionStats} of statistics.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.solve_problems" href="#SolverTools.solve_problems"><code>SolverTools.solve_problems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_problems(solver, problems :: Any; kwargs...)</code></pre><p>Apply a solver to a set of problems.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: the function name of a solver</li><li><code>problems</code>: the set of problems to pass to the solver, as an iterable of <code>AbstractNLPModel</code>.  It is recommended to use a generator expression (necessary for CUTEst problems).</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>solver_logger::AbstractLogger</code>: logger wrapping the solver call. (default: <code>NullLogger</code>).</li><li><code>skipif::Function</code>: function to be applied to a problem and return whether to skip it (default: <code>x-&gt;false</code>)</li><li><code>prune</code>: do not include skipped problems in the final statistics (default: <code>true</code>)</li><li>any other keyword argument to be passed to the solver</li></ul><p><strong>Return value</strong></p><ul><li>a <code>DataFrame</code> where each row is a problem, minus the skipped ones if <code>prune</code> is true.</li></ul></div></div></section><h2><a class="nav-anchor" id="Line-Search-1" href="#Line-Search-1">Line-Search</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.LineModel" href="#SolverTools.LineModel"><code>SolverTools.LineModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A type to represent the restriction of a function to a direction. Given f : R → Rⁿ, x ∈ Rⁿ and a nonzero direction d ∈ Rⁿ,</p><pre><code class="language-none">ϕ = LineModel(nlp, x, d)</code></pre><p>represents the function ϕ : R → R defined by</p><pre><code class="language-none">ϕ(t) := f(x + td).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NLPModels.obj" href="#NLPModels.obj"><code>NLPModels.obj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>obj(f, t)</code> evaluates the objective of the <code>LineModel</code></p><pre><code class="language-none">ϕ(t) := f(x + td).</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NLPModels.grad" href="#NLPModels.grad"><code>NLPModels.grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>grad(f, t)</code> evaluates the first derivative of the <code>LineModel</code></p><pre><code class="language-none">ϕ(t) := f(x + td),</code></pre><p>i.e.,</p><pre><code class="language-none">ϕ&#39;(t) = ∇f(x + td)ᵀd.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NLPModels.grad!" href="#NLPModels.grad!"><code>NLPModels.grad!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>grad!(f, t, g)</code> evaluates the first derivative of the <code>LineModel</code></p><pre><code class="language-none">ϕ(t) := f(x + td),</code></pre><p>i.e.,</p><pre><code class="language-none">ϕ&#39;(t) = ∇f(x + td)ᵀd.</code></pre><p>The gradient ∇f(x + td) is stored in <code>g</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NLPModels.hess" href="#NLPModels.hess"><code>NLPModels.hess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Evaluate the second derivative of the <code>LineModel</code></p><pre><code class="language-none">ϕ(t) := f(x + td),</code></pre><p>i.e.,</p><pre><code class="language-none">ϕ&quot;(t) = dᵀ∇²f(x + td)d.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.redirect!" href="#SolverTools.redirect!"><code>SolverTools.redirect!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>redirect!(ϕ, x, d)</code></p><p>Change the values of x and d of the LineModel ϕ, but retains the counters.</p></div></div></section><h2><a class="nav-anchor" id="Stats-1" href="#Stats-1">Stats</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.GenericExecutionStats" href="#SolverTools.GenericExecutionStats"><code>SolverTools.GenericExecutionStats</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GenericExecutionStats(status, nlp; ...)</code></pre><p>A GenericExecutionStats is a struct for storing output information of solvers. It contains the following fields:</p><ul><li><code>status</code>: Indicates the output of the solver. Use <code>show_statuses()</code> for the full list;</li><li><code>solution</code>: The final approximation returned by the solver (default: <code>[]</code>);</li><li><code>objective</code>: The objective value at <code>solution</code> (default: <code>Inf</code>);</li><li><code>dual_feas</code>: The dual feasibility norm at <code>solution</code> (default: <code>Inf</code>);</li><li><code>primal_feas</code>: The primal feasibility norm at <code>solution</code> (default: <code>0.0</code> if uncontrained, <code>Inf</code> otherwise);</li><li><code>iter</code>: The number of iterations computed by the solver (default: <code>-1</code>);</li><li><code>elapsed_time</code>: The elapsed time computed by the solver (default: <code>Inf</code>);</li><li><code>counters::NLPModels.NLSCounters</code>: The Internal structure storing the number of functions evaluations;</li><li><code>solver_specific::Dict{Symbol,Any}</code>: A solver specific dictionary.</li></ul><p>The <code>counters</code> variable is a copy of <code>nlp</code>&#39;s counters, and <code>status</code> is mandatory on construction. All other variables can be input as keyword arguments.</p><p>Notice that <code>GenericExecutionStats</code> does not compute anything, it simply stores.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.show_statuses" href="#SolverTools.show_statuses"><code>SolverTools.show_statuses</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">show_statuses()</code></pre><p>Show the list of available statuses to use with <code>GenericExecutionStats</code>.</p></div></div></section><h2><a class="nav-anchor" id="Trust-Region-1" href="#Trust-Region-1">Trust-Region</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.TrustRegionException" href="#SolverTools.TrustRegionException"><code>SolverTools.TrustRegionException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Exception type raised in case of error.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.AbstractTrustRegion" href="#SolverTools.AbstractTrustRegion"><code>SolverTools.AbstractTrustRegion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>AbstractTrustRegion</code></p><p>An abstract trust region type so that specific trust regions define update rules differently. Child types must have at least the following fields:</p><ul><li><code>acceptance_threshold :: AbstractFloat</code></li><li><code>initial_radius :: AbstractFloat</code></li><li><code>radius :: AbstractFloat</code></li><li><code>ratio :: AbstractFloat</code></li></ul><p>and the following function:</p><ul><li><code>update!(tr, step_norm)</code></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.aredpred" href="#SolverTools.aredpred"><code>SolverTools.aredpred</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>ared, pred = aredpred(nlp, f, f_trial, Δm, x_trial, step, slope)</code></p><p>Compute the actual and predicted reductions <code>∆f</code> and <code>Δm</code>, where <code>Δf = f_trial - f</code> is the actual reduction is an objective/merit/penalty function, <code>Δm = m_trial - m</code> is the reduction predicted by the model <code>m</code> of <code>f</code>. We assume that <code>m</code> is being minimized, and therefore that <code>Δm &lt; 0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.acceptable" href="#SolverTools.acceptable"><code>SolverTools.acceptable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>acceptable(tr)</code></p><p>Return <code>true</code> if a step is acceptable</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearOperators.reset!" href="#LinearOperators.reset!"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>reset!(tr)</code></p><p>Reset the trust-region radius to its initial value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.get_property" href="#SolverTools.get_property"><code>SolverTools.get_property</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A basic getter for <code>AbstractTrustRegion</code> instances. Should be overhauled when it&#39;s possible to overload <code>getfield()</code> and <code>setfield!()</code>. See https://github.com/JuliaLang/julia/issues/1974</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.set_property!" href="#SolverTools.set_property!"><code>SolverTools.set_property!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>A basic setter for <code>AbstractTrustRegion</code> instances.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.update!" href="#SolverTools.update!"><code>SolverTools.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>update!(tr, step_norm)</code></p><p>Update the trust-region radius based on the ratio of actual vs. predicted reduction and the step norm.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.TrustRegion" href="#SolverTools.TrustRegion"><code>SolverTools.TrustRegion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Basic trust region type.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverTools.TRONTrustRegion" href="#SolverTools.TRONTrustRegion"><code>SolverTools.TRONTrustRegion</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Trust region used by TRON</p></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../reference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
